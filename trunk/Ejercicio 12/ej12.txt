12)
Para el diseño de semáforos se eligió la esctructura que se ve en el archivo semaf.h.
El typedef semaforo se creó para que el usuario del semáforo no posea más información del mismo que el id.
La estructura semaf es la que guarda toda la información sensible para el manejo de los semáforos y el arreglo semaforos hace las veces de objeto contenedor de los mismos.
El nombre del semáforo se usa para identificarlo, y tiene un largo máximo dado por el largo de M3_STRING, que es un arreglo de char de 15 posiciones.
Se tomó esta decisión porque fue mas simple manejar el nombre del semáforo a través de un arreglo que con punteros.
El flag semafEnUso sirve para saber si un semaforo tiene asignado algún proceso. Estos se agregan en la lista procEnUso, en el primer lugar vacio que encuentren.
El campo valor, indica el valor del semáforo ( ya que son semáforos contadores ).
La cola de procesos bloqueados está implementada sobre un arreglo y 2 apuntadores, al inicio y al fin de la lista respectivamente. La lista va haciendose circular por el arreglo, una vez que se llega al final del mismo, vuelve a comenzar.

El usuario posee las siguientes funciones para el manejo de semáforos:

semaforo crear_sem(char* nombre, int valor) : A partir de un nombre y un valor crea un semáforo, le asigna nombre, valor y el proceso que lo creó. Retorna un "semaforo" (int). Si el nombre ya existía en la lista de semáforos, asigna al proceso creador e ignora el valor entregado. Si no hay más semáforos disponibles retorna mensaje de error.

int p_sem(semaforo x) : Ejecuta P al semáforo x. Decrementa el valor del semáforo. Si el valor resulta quedar en 0 o menor, el proceso se bloquea, se agrega a la cola de bloqueados. Si el semáforo no pertenecía al proceso se retorna mensaje de error.

int v_sem(semaforo x) : Ejecuta V al semáforo x. Incrementa el valor del semáforo. Si el valor resulta quedar en 0 o menor, el primer proceso de la cola de bloqueados se libera. Si el semáforo no pertenecía al proceso se retorna mensaje de error.

int liberar_sem(semaforo x) : Dado un semáforo x libera a todos los procesos bloqueados en él, borra los procesos de la lista e inicializa al semáforo. Este método viola la exclusión mutua.

void inicializar() : Vacia las listas de procesos, flags, valor y nombre de todos los semáforos


Cambios para ejercicio 12

/usr/include/minix/callnr.h
Se incrementó en 5 el define NCALLS ( Se definieron 5 llamadas a sistema )
Se agregó #define CREAR_SEM con el nro correspondiente
Se agregó #define P_SEM con el nro correspondiente
Se agregó #define V_SEM con el nro correspondiente
Se agregó #define LIBERAR_SEM con el nro correspondiente
Se agregó #define INIT_ALL_SEM con el nro correspondiente

/usr/src/mm/proto.h
Se agrega linea:

_PROTOTYPE( int do_crear_sem, (void)	);
_PROTOTYPE( int do_p_sem, (void)		);
_PROTOTYPE( int do_v_sem, (void)		);
_PROTOTYPE( int do_liberar_sem, (void)	);
_PROTOTYPE( int do_init_all_sem, (void)	);

/usr/src/mm/table.c
Se agregan lineas:

do_crear_sem, 		/* 80 = CREAR_SEM		*/
do_p_sem, 			/* 81 = P_SEM 			*/
do_v_sem, 			/* 82 = V_SEM			*/
do_liberar_sem, 	/* 83 = LIBERAR_SEM		*/
do_init_all_sem, 	/* 84 = INIT_ALL_SEM	*/

/usr/src/fs/table.c
Se agregan lineas:

no_sys, 			/* 80 = CREAR_SEM		*/
no_sys, 			/* 81 = P_SEM 			*/
no_sys, 			/* 82 = V_SEM			*/
no_sys, 			/* 83 = LIBERAR_SEM		*/
no_sys, 			/* 84 = INIT_ALL_SEM	*/

Se define estructura del semáforo en:
/usr/src/mm/semaf.h (archivo source)

Se implementan system call en:
/usr/src/mm/semaf.c (archivo source)

Se actualiza Makefile de /usr/src/mm para incluirlos.

Se crea
/usr/include/minix/constsemaf.h  (archivo source)
Posee unos defines para renombrar los parámetros del mensaje

Se actualiza archivo system.c para agregar los system call encargados de bloquear y desbloquear un proceso.
/usr/src/kernel/system.c (archivo source)

Se recompila kernel

Ejecutar

# /usr/src/tools/make install
# /usr/src/tools/make hdboot

Se crean archivos para poder llamar el system call desde una librería y cumplir el standard posix:
/usr/src/lib/syscall/crear_sem.s (archivo source)
/usr/src/lib/syscall/p_sem.s (archivo source)
/usr/src/lib/syscall/v_sem.s (archivo source)
/usr/src/lib/syscall/liberar_sem.s (archivo source)
/usr/src/lib/syscall/init.s (archivo source)
Se actualiza Makefile de /usr/src/lib/syscall para incluirlo.

/usr/src/lib/posix/_sem.c (archivo source)
Se actualiza Makefile de /usr/src/lib/posix para incluirlo.

Se crean archivos para poder manejar como función los system call al kernel:
/usr/src/lib/syslib/sys_block.c (archivo source)
/usr/src/lib/syslib/sys_unblock.c (archivo source)
Se actualiza Makefile de /usr/src/lib/syslib para incluirlo.

/usr/include/minix/syslib.h
Se agregan lineas:
_PROTOTYPE( int sys_block, (int_proc)	);
_PROTOTYPE( int sys_block, (int_proc)	);

Ejecutar

# /usr/src/lib/make all
# /usr/src/lib/make install

Pruebas ejercicio 12
En imagen minix para ejercicio 12

Directorio /usr/ej12:

Están implementados productor consumidor y secuencia de procesos A-B-B-A-C

a)productor consumidor

Ejecutar

# ./init --> inicializa semáforos
# ./prod-cons --> define semáforos x e y para pruebas productor consumidor

# ./productor  > /dev/null &   --> ejecuta productor en 2do plano
# ./consumidor > /dev/null &  --> ejecuta consumidor en 2do plano

Ejecutar indistintamente productor y consumidor. Cada vez que se produzca algo se mostrará en consola "Produce" y cada vez que se consuma, "Consume"

Para finalizar la prueba ejecutar:

# ./libsem  --> libera todos los procesos bloqueados


b)Secuencia A-B-B-A-C

Ejecutar

# ./init --> inicializa semáforos
# ./sem --> define todos los semáforos necesarios

Los procesos involucrados son ./A ./B o ./C . Cada vez que se ejecutan se muestra en consola "este es A", "este es B" o "este es C" respectivamente.

# ./A > /dev/null &   --> ejecuta A en 2do plano
# ./B > /dev/null &   --> ejecuta B en 2do plano
# ./C > /dev/null &  --> ejecuta C en 2do plano

Hay un script ( pru.sh ) que tiene un ejemplo:
 ./A & ./A & ./A & ./B & ./B & ./B & ./C & ./C & ./C & >  /dev/null &

Que debería mostrar lo siguiente:
este es A
este es B
este es B
este es A
este es C
este es A
este es B

Ejecutando el comando

# ps

Podemos corroborar que existen 2 procesos C que están bloqueados.

Para finalizar la prueba ejecutar:

# ./libsem  --> libera todos los procesos bloqueados









Ejecutar indistintamente productor y consumidor. Cada vez que se produzca algo se mostrará en consola "Produce" y cada vez que se consuma, "Consume"

Para finalizar la prueba ejecutar:

# ./libsem  --> libera todos los procesos bloqueados
