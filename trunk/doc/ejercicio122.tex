\subsection{Ejercicio 12}

\clearpage
\section{Ap'endice A}
A continuaci'on se muestra el c'odigo de la funci'on $do\_clocktick$ que no se ejecutar'a si est'a definido UBA\_FCEN. Dicha funci'on se encuentra en el archivo \textbf{/usr/src/kernel/clock.c}.

\begin{verbatim}
[...]
#ifndef UBA_FCEN
  /* If a user process has been running too long, pick another one. */

  if (--sched_ticks == 0) {
        if (bill_ptr == prev_ptr) lock_sched(); /* process has run too long */
        sched_ticks = SCHED_RATE;               /* reset quantum */
        prev_ptr = bill_ptr;                    /* new previous process */
  }
#endif
\end{verbatim}



Aqu'i se ver'a como fue modificada la funci'on $alloc\_mem$, la cual se encuentra en el archivo \textbf{/usr/src/mm/alloc.c}.

\begin{verbatim}
[...]
/*======================================================================*
* alloc_mem *
*======================================================================*/
#ifdef UBA_FCEN

PUBLIC phys_clicks alloc_mem(clicks)
phys_clicks clicks; 
{
  register struct hole *max, *anterior;
  phys_clicks old_base;
  register struct hole *actual, *debugg;
  actual = hole_head;
  max = hole_head;

#ifdef DEBUGG

  /*DEBUGER: para ver como es el estado inicial de la memoria*/
  debugg = hole_head;
  printf("Se quiere reservar %d espacios de memoria \n",clicks);
  while (debugg != NIL_HOLE)
  {
    printf("%d ",debugg->h_len);
    debugg = debugg->h_next;
  }
  printf("\n");
  /***********************************************************/

#endif

  while (actual->h_next != NIL_HOLE)
  {
    if (actual->h_next->h_len > max->h_len)
    {
      max = actual->h_next;
      anterior = actual;
    }
    actual = actual->h_next;
  }

  if (max->h_len < clicks)
  }
    return(NO_MEM);
  }
  else
  {
    old_base = max->h_base;
    max->h_base += clicks;
    max->h_len -= clicks;
  }

  if (max->h_len == 0)
  {
    del_slot(anterior, max);
  }

#ifdef DEBUGG

  /*DEBUG: para ver como queda la memoria una vez hecha la alicacion*/
  debugg = hole_head;
  printf("Los segmentos de memoria quedaron de la siguiente manera \n");
  while (debugg != NIL_HOLE)
  {
    printf("%d ",debugg->h_len);
    debugg = debugg->h_next;
  }
  printf("\n");
  /******************************************************************/

#endif

  return(old_base);
}

#else

PUBLIC phys_clicks alloc_mem(clicks)
phys_clicks clicks;             /* amount of memory requested */
{
/* Allocate a block of memory from the free list using first fit. The block
 * consist of a sequence of contiguous bytes, whose length in clicks is 
 * given by 'clics'.  A pointer to the block is returned.  The block is 
 * always on a click boundary. This procedure is called when memory is
 * needed for FORK or EXEC.
 */
  
  register struct hole *hp, *prev_ptr;
  phys_clicks old_base;

  hp = hole_head;
  while (hp != NIL_HOLE) {
        if (hp->h_len >= clicks) {
            /* We found a hole that is big enough.  Use it. */
            old_base = hp->h_base;  /* remember where it started */
            hp->h_base += clicks;   /* bite a piece off */
            hp->h_len -= clicks;    /* ditto */

            /* If hole is only partly used, reduce size and return. */
            if (hp->h_len != 0) return (old _base);

            /* The entire hole has been used up.  Manipulate free list. */
            del_slot(prev_ptr, hp);
            return(old_base);
        }
        
        prev_ptr = hp;
        hp = hp->h_next;
  }
  return(NO_MEM);
}

#endif
[...]
\end{verbatim}
