\subsection{Ejercicio 12}
Para el diseño de semáforos se eligi'o la esctructura que se ve en el archivo semaf.h. El typedef semaforo se cre'o para que el usuario del semáforo no posea más informaci'on del mismo que el id. La estructura semaf es la que guarda toda la informaci'on sensible para el manejo de los semáforos y el arreglo semaforos hace las veces de objeto contenedor de los mismos. El nombre del semáforo se usa para identificarlo, y tiene un largo máximo dado por el largo de \verbºM3_STRINGº, que es un arreglo de char de 15 posiciones. Se tom'o esta decisi'on porque fue mas simple manejar el nombre del semáforo a través de un arreglo que con punteros. El flag semafEnUso sirve para saber si un semaforo tiene asignado algún proceso. Estos se agregan en la lista procEnUso, en el primer lugar vacio que encuentren. El campo valor, indica el valor del semáforo ( ya que son semáforos contadores ). La cola de procesos bloqueados está implementada sobre un arreglo y 2 apuntadores, al inicio y al fin de la lista respectivamente. La lista va haciendose circular por el arreglo, una vez que se llega al final del mismo, vuelve a comenzar.

El usuario posee las siguientes funciones para el manejo de semáforos:

\verbºsemaforo crear_sem(char* nombre, int valor)º : A partir de un nombre y un valor crea un semáforo, le asigna nombre, valor y el proceso que lo cre'o. Retorna un ''semaforo'' (int). Si el nombre ya existía en la lista de semáforos, asigna al proceso creador e ignora el valor entregado. Si no hay más semáforos disponibles retorna mensaje de error.

\verbºint p_sem(semaforo x)º : Ejecuta P al semáforo x. Decrementa el valor del semáforo. Si el valor resulta quedar en 0 o menor, el proceso se bloquea, se agrega a la cola de bloqueados. Si el semáforo no pertenecía al proceso se retorna mensaje de error.

\verbºint v_sem(semaforo x)º : Ejecuta V al semáforo x. Incrementa el valor del semáforo. Si el valor resulta quedar en 0 o menor, el primer proceso de la cola de bloqueados se libera. Si el semáforo no pertenecía al proceso se retorna mensaje de error.

\verbºint liberar_sem(semaforo x)º : Dado un semáforo x libera a todos los procesos bloqueados en él, borra los procesos de la lista e inicializa al semáforo. Este método viola la exclusi'on mutua.

\verbºvoid inicializar()º : Vacia las listas de procesos, flags, valor y nombre de todos los semáforos

\vspace{1cm}

\subsubsubsection{Cambios para ejercicio 12}

\verbº/usr/include/minix/callnr.hº

\begin{list}{}{}
\item Se increment'o en 5 el define \verbºNCALLSº ( Se definieron 5 llamadas a sistema )
\item Se agreg'o \verbº#define CREAR_SEMº con el nro correspondiente
\item Se agreg'o \verbº#define P_SEMº con el nro correspondiente
\item Se agreg'o \verbº#define V_SEMº con el nro correspondiente
\item Se agreg'o \verbº#define LIBERAR_SEMº con el nro correspondiente
\item Se agreg'o \verbº#define INIT_ALL_SEMº con el nro correspondiente
\end{list}

\verbº/usr/src/mm/proto.hº

Se agrega linea:

\begin{verbatim}
_PROTOTYPE( int do_crear_sem, (void)	);
_PROTOTYPE( int do_p_sem, (void)		);
_PROTOTYPE( int do_v_sem, (void)		);
_PROTOTYPE( int do_liberar_sem, (void)	);
_PROTOTYPE( int do_init_all_sem, (void)	);
\end{verbatim}

\verbº/usr/src/mm/table.cº

Se agregan lineas:

\begin{verbatim}
do_crear_sem, 		/* 80 = CREAR_SEM		*/
do_p_sem, 			/* 81 = P_SEM 			*/
do_v_sem, 			/* 82 = V_SEM			*/
do_liberar_sem, 	/* 83 = LIBERAR_SEM		*/
do_init_all_sem, 	/* 84 = INIT_ALL_SEM	*/
\end{verbatim}

\verbº/usr/src/fs/table.cº

Se agregan lineas:

\begin{verbatim}
no_sys, 			/* 80 = CREAR_SEM		*/
no_sys, 			/* 81 = P_SEM 			*/
no_sys, 			/* 82 = V_SEM			*/
no_sys, 			/* 83 = LIBERAR_SEM		*/
no_sys, 			/* 84 = INIT_ALL_SEM	*/
\end{verbatim}

Se define estructura del semáforo en:
\verbº/usr/src/mm/semaf.hº (archivo source)

Se implementan system call en:
\verbº/usr/src/mm/semaf.cº (archivo source)

Se actualiza Makefile de \verbº/usr/src/mmº para incluirlos.

Se crea
\verbº/usr/include/minix/constsemaf.hº  (archivo source)
Posee unos defines para renombrar los parámetros del mensaje

Se actualiza archivo system.c para agregar los system call encargados de bloquear y desbloquear un proceso.
\verbº/usr/src/kernel/system.cº (archivo source)

Se recompila kernel

Ejecutar

\begin{verbatim}
# /usr/src/tools/make install
# /usr/src/tools/make hdboot
\end{verbatim}

Se crean archivos para poder llamar el system call desde una librería y cumplir el standard posix:

\begin{verbatim}
/usr/src/lib/syscall/crear_sem.s (archivo source)
/usr/src/lib/syscall/p_sem.s (archivo source)
/usr/src/lib/syscall/v_sem.s (archivo source)
/usr/src/lib/syscall/liberar_sem.s (archivo source)
/usr/src/lib/syscall/init.s (archivo source)
\end{verbatim}
Se actualiza Makefile de \verbº/usr/src/lib/syscallº para incluirlo.

\verbº/usr/src/lib/posix/_sem.cº (archivo source)
Se actualiza Makefile de \verbº/usr/src/lib/posixº para incluirlo.

Se crean archivos para poder manejar como funci'on los system call al kernel:
\begin{verbatim}
/usr/src/lib/syslib/sys_block.c (archivo source)
/usr/src/lib/syslib/sys_unblock.c (archivo source)
\end{verbatim}
Se actualiza Makefile de \verbº/usr/src/lib/syslibº para incluirlo.

\verbº/usr/include/minix/syslib.hº

Se agregan lineas:
\begin{verbatim}
_PROTOTYPE( int sys_block, (int_proc)	);
_PROTOTYPE( int sys_block, (int_proc)	);
\end{verbatim}

Ejecutar

\begin{verbatim}
# /usr/src/lib/make all
# /usr/src/lib/make install
\end{verbatim}

\subsubsection{Pruebas ejercicio 12}
En imagen minix para ejercicio 12

Directorio \verbº/usr/ej12º:

Están implementados productor consumidor y secuencia de procesos A-B-B-A-C

\vspace{1cm}
\subsubsubsection{Productor-Consumidor}

Ejecutar

\begin{verbatim}
# ./init --> inicializa semáforos
# ./prod-cons --> define semáforos x e y para pruebas productor consumidor

# ./productor  > /dev/null &   --> ejecuta productor en 2do plano
# ./consumidor > /dev/null &  --> ejecuta consumidor en 2do plano
\end{verbatim}

Ejecutar indistintamente productor y consumidor. Cada vez que se produzca algo se mostrará en consola ''Produce'' y cada vez que se consuma, ''Consume''

Para finalizar la prueba ejecutar:

\verbº# ./libsemº

que libera todos los procesos bloqueados

\vspace{1cm}
\subsubsubsection{Secuencia A-B-B-A-C}

Ejecutar

\begin{verbatim}
# ./init --> inicializa semáforos
# ./sem --> define todos los semáforos necesarios
\end{verbatim}

Los procesos involucrados son ./A ./B o ./C . Cada vez que se ejecutan se muestra en consola ''este es A'', ''este es B'' o ''este es C'' respectivamente.

\begin{verbatim}
# ./A > /dev/null &   --> ejecuta A en 2do plano
# ./B > /dev/null &   --> ejecuta B en 2do plano
# ./C > /dev/null &  --> ejecuta C en 2do plano
\end{verbatim}

Hay un script ( pru.sh ) que tiene un ejemplo:

\verbº ./A & ./A & ./A & ./B & ./B & ./B & ./C & ./C & ./C & >  /dev/null &º

Que debería mostrar lo siguiente:
\begin{verbatim}
este es A
este es B
este es B
este es A
este es C
este es A
este es B
\end{verbatim}

Ejecutando el comando

\verbº# psº

Podemos corroborar que existen 2 procesos C que están bloqueados.

Ejecutar indistintamente productor y consumidor. Cada vez que se produzca algo se mostrará en consola ''Produce'' y cada vez que se consuma, ''Consume''

Para finalizar la prueba ejecutar:

\verbº# ./libsemº

que libera todos los procesos bloqueados

