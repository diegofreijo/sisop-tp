\documentclass[spanish, a4paper, 11pt]{article}

\usepackage[a4paper,margin=3.5cm,top=3.0cm,bottom=3.0cm]{geometry}	% Define los margenes
\usepackage[spanish,activeacute]{babel}								% Idioma castellano
\usepackage{caratula}														% Caratula de Algo2
%\usepackage[a4paper=true,pagebackref=true]{hyperref}				% Agrega la TOC al PDF e hipervinculos
%\usepackage[pdftex]{graphicx} 											% Permite insertar graficos
%\usepackage{fancyhdr}														% Permite manejo de cabeceras de pagina
\usepackage{eufrak}															% Usado en el enunciado del trabajo
\usepackage{latexsym}
%\usepackage{algorithmic}													% Para escribir los algos
%\usepackage{dsfont}															% Para el simbolo de naturales
%\usepackage[font=small,labelfont=bf]{caption}						% Para editar las captions


% Estilo de pagina para tener las cabeceras
%\pagestyle{fancy}
%\lhead{Sistemas Operativos}
%\rhead{Diego Freijo - Maximiliano Giusto - Ignacio Iacobacci}

% Numeracion de paginas
\pagenumbering{arabic}
\parskip=1.5ex

% Seteo de estilo de los algoritmos
%\algsetup{indent=2em}

\newcommand{\imagen}[3]
{
	\begin{figure}[htbp]
	  \centering
%	    \includegraphics[scale=0.5]{#1}
	  \caption{#3}
	\end{figure}
}

\newcommand{\nat}{\mathds{N}}
\newcommand{\algoritmo}[3]{\noindent {\bf\underline{#1}:} #2 $\longrightarrow$ #3}
\newcommand{\superindice}[1]{$^\textrm{{\tiny #1}}$}
\newcommand{\subsubsubsection}[1]{

{\bf\small #1}

}
\newcommand{\negrita}[1]{{\bf #1}}

\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}   
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%   Inicio del documento
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Caratula
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\materia{Algoritmos y Estructuras de Datos III}
\submateria{Primer Cuatrimestre de 2007}
\titulo{Trabajo Pr'actico 2}
\subtitulo{}
\integrante{Freijo, Diego}{4/05}{giga.freijo@gmail.com}
\integrante{Giusto, Maximiliano}{486/05}{maxi.giusto@gmail.com}
\integrante{Iacobacci, Ignacio}{322/02}{iiacobac@gmail.com}
\maketitle

\subsection*{Palabras Clave}
Minix, Kernell, Memoria, Perifericos, Drivers

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\tableofcontents
\newpage

\section{Soluciones}
\subsection{Ejercicio 1}
\subsection{Ejercicio 2: Herramientas}

Indique que hace el comando make y mknode. C'omo se utilizan 'estos comandos en la instalaci'on de MINIX y en la creaci'on de un nuevo kernel. Para el caso del make muestre un archivo ejemplo y explique que realiza cada uno de los comandos internos del archivo ejemplo.

El comando make sirve para compilar archivos. Make es un programa que es normalmente usado para desarrollar programas grandes que consisten en muchos archivos. Lleva cuenta de cuales archivos objeto dependen de cuales archivos fuentes y de cabecera. Cuando es ejecutado, hace la m'inima cantidad de recompilaciones para obtener el archivo destino actualizado.
El comando make se utiliza en la creaci'on de un nuevo kernel. Luego de modificar alg'un archivo fuente del kernel, uno debe reconstruir el kernel. En el directorio \textbf{/usr/src/tools} est'an todos los archivos necesarios para reconstruir el kernel.

El comando mknod sirve para crear archivos especiales ya sea archivos asociados a dispositivos de entrada/salida o bien directorios. El uso de 'este comando est'a reservado a los superusuarios.

A pesar de que en la instalaci'on de MINIX nosotros no tuvimos que, expl'icitamente, usar estos comandos, el comando mknod se utiliz'o para crear los nodos device en el nodo ra'iz: \textbf{/dev/tty}; \textbf{/dev/tty[0-2]}; \textbf{/dev/hd[0-9]}.



\subsection{Ejercicio 3: Comandos b'asicos MINIX/UNIX}
\subsubsection{Pongale password root a root.}

Utilizando el comando passwd:

\begin{verbatim}
    # passwd
    Changing the shadow password of root
    New password:
    Retype password:
    # exit
    Minix Release 2.0 Version 0
    noname login: root
    Password:
    #
\end{verbatim}

\subsubsection{pwd}

Indique qué directorio pasa a ser su $current\ directory$ si ejecuta:

\subsubsubsection{1.3.2.1. $\sharp$ cd /usr/src}

\begin{verbatim}
    # cd /usr/src
    # pwd
    /usr/src
\end{verbatim}

Utilizando el comando \textbf{pwd} podemos ver en que directorio nos encontramos. En 'este caso el $current\ directory$ es \textbf{/usr/src}.

\subsubsubsection{1.3.2.2. $\sharp$ cd}

\begin{verbatim}
    # cd
    # pwd
    /
    #
\end{verbatim}

Nuevamente utilizamos el comando \textbf{pwd} y el directorio actual es \textbf{/}.

\subsubsubsection{1.3.2.3. ¿C'omo explica el punto 1.3.2.2.?}

Ejecutar el comando \textbf{cd} sin argumentos cambia el directorio actual al directorio home del usuario. Para el usuario root 'este directorio es el directorio ra'iz del sistema.

\subsubsection{cat}

Cu'al es el contenido del archivo \textbf{/usr/src/.profile} y para qu'e sirve.

\begin{verbatim}
    # cat /usr/src/.profile
    # Login shell profile.
    
    # Environment.
    umask 022
    PATH=/usr/local/bin:/bin:/usr/bin
    PS1="! "
    export PATH
    
    # Erase character, erase line, and interrupt keys.
    stty erase '^H' kill '^U' intr '^?'
    # Check terminal type.
    case $TERM in
    dialup|unknown|network)
            echo -n "Terminal type? ($TERM) "; read term
            TERM="${term:-$TERM}"
    esac
    
    # Shell configuration.
    case "$0" in *ash) . $HOME/.ashrc;; esac
    #
\end{verbatim}

Cada usuario tendr'a 'este script en su home, y cada vez que se "loguee" se ejecutar'a.

\subsubsection{find}

En qu'e directorio se encuentra el archivo \textbf{proc.c}

\begin{verbatim}
    # find / -name proc.c
    /usr/src/kernel/proc.c
\end{verbatim}

\subsubsection{mkdir}

Genere un directorio \textbf{/usr/$<$nombregrupo$>$}

\begin{verbatim}
    #mkdir /usr/grupo8
    # cd /usr
    # ls
    adm bin grupo8  lib   man  preserve src
    ast etc include local mdec spool    tmp
\end{verbatim}

\subsubsection{cp}

Copie el archivo \textbf{/etc/passwd} al directorio \textbf{/usr/$<$nombregrupo$>$}

\begin{verbatim}
    # cp /etc/passwd /usr/grupo8/passwd
    # cd /usr/grupo8
    # ls
    passwd
    #
\end{verbatim}

\subsubsection{chgrp}

Cambie el grupo del archivo \textbf{/usr/$<$grupo$>$/passwd} para que sea other.
\begin{verbatim}
    # pwd
    /usr/grupo8
    # ls -l
    total 1
    -rw-r--r-- 1 root operator 285 Jun 17 22:05 passwd
    # chgrp other passwd
    # ls -l
    total 1
    -rw-r--r-- 1 root other 285 Jun 17 22:05 passwd
    #
\end{verbatim}

\subsubsection{chown}

Cambie el propietario del archivo \textbf{/usr/$<$grupo$>$/passwd} para que sea \textbf{ast}.

\begin{verbatim}
    # chown ast passwd
    # ls -l
    total 1
    -rw-r--r-- 1 ast other 285 Jun 17 22:06 passwd
    #
\end{verbatim}

\subsubsection{chmod}

Cambie los permisos del archivo \textbf{/usr/$<$grupo$>$/passwd} para que:

\begin{itemize}
\item el propietario tenga permisos de lectura, escritura y ejecuci'on
\item el grupo tenga solo permisos de lectura y ejecuci'on
\item el resto tenga solo permisos de ejecuci'on
\end{itemize}

\begin{verbatim}
    # chmod 751 passwd
    # ls -l
    total 1
    -rwxr-x--x 1 ast other 285 Jun 17 22:11 passwd
    #
\end{verbatim}

\subsubsection{grep}

Muestre las lineas que tiene el texto \textbf{include} en el archivo \textbf{/usr/src/kernel/main.c}

\begin{verbatim}
    # grep include /usr/src/kernel/main.c
    #include "kernel.h"
    #include <signal.h>
    #include <unistd.h>
    #include <minix/callnr.h>
    #include <minix/com.h>
    #include "proc.h"
    #
\end{verbatim}

Muestre las lineas que tiene el texto \textbf{POSIX} que se encuentren en todos los archivos \textbf{/usr/src/kernel/}

\begin{verbatim}
# grep POSIX /usr/src/kernel/*
/usr/src/kernel/kernel.h:#define _POSIX_SOURCE 1 /* tell headers to inclu
de POSIX stuff */
/usr/src/kernel/rs232.c: if ((tp->tty_termios.c_lflag & IXON) && rs->oxoff !=
_POSIX_VDISABLE)
/usr/src/kernel/system.c: * SYS_SENDSIG send a signal to a process (POSIX style)
/usr/src/kernel/system.c: * SYS_SIGRETURN complete POSIX-style signalling
/usr/src/kernel/system.c:/* Handle sys_sendsig, POSIX-style signal */
/usr/src/kernel/system.c:/* POSIX style signals require sys_sigreturn to put
things in order before the
/usr/src/kernel/tty.c:/* These Posix functions are allowed to fail if _POSIX_JOB
_CONTROL is
/usr/src/kernel/tty.c: /* _POSIX_VDISABLE is a normal character value, so better
escape it. */
/usr/src/kernel/tty.c: if (ch == _POSIX_VDISABLE) ch |= IN_ESC;
#
\end{verbatim}

\subsubsection{su}

\subsubsubsection{1.3.11.1. Para qu'e sirve?}

Permite convertir un usuario en otro sin tener que desconectarse del sistema.
Por defecto lo convierte en superuser. Le pedir'a la password correspondiente.

\subsubsubsection{1.3.11.2. Qu'e sucede si ejecuta el comando \textbf{su} estando logueado como \textbf{root}?}

Se genera un shell nuevo. Como estabamos logueados como root, no pidi'o password.

\subsubsubsection{1.3.11.3. Genere una cuenta de $<$usuario$>$}
%el usuario es Maxi pero me pareció mejor poner pepe

\begin{verbatim}
    # adduser pepe other /usr/pepe
    cpdir /usr/ast /usr/pepe
    chown -R 10:3 /usr/pepe
    echo pepe::0:0::: >>/etc/shadow
    echo pepe:##pepe:10:3:pepe:/usr/pepe: >>/etc/passwd
    The new user pepe has been added to the system. Note that the password,
    full name, and shell may be changed with the commands passwd(1), chfn(1),
    and chsh(1). The password is now empty, so only console logins are possible.
\end{verbatim}

\subsubsubsection{1.3.11.4. Entre a la cuenta $<$usuario$>$ generada}

\begin{verbatim}
    Minix Release 2.0 Version 0
    noname login: pepe
    $
\end{verbatim}

No pidi'o Password pues el usuario pepe no tiene a'un una seteada.
 
\subsubsubsection{1.3.11.5. Repita los comandos de 1.3.11.2}

Estando logueado como pepe ejecutamos el comando \textbf{su}.

\begin{verbatim}
    $ su
    Password:
    #
\end{verbatim}

Nos pide la password de root pues el usuario pepe es parte del grupo other. Si fuera parte del grupo operator no la pedir'ia.

\subsubsection{passwd}

\subsubsubsection{1.3.12.1. Cambie la password del usuario nobody}

\begin{verbatim}
    # passwd nobody
    Changing the password of nobody
    New password:
    Retype password:
    #
\end{verbatim}

\subsubsubsection{1.3.12.2. Presione las teclas ALT-F2 y ver'a otra sesi'on MINIX. Loguearse como nobody }

\begin{verbatim}
    Minix Release 2.0 Version 0
    noname login: nobody
    Password:
    $
\end{verbatim}

Nos logueamos con password nobody.

\subsubsubsection{1.3.12.3. Ejecutar el comando su}

\begin{verbatim}
    $ su
    Password:
    #
\end{verbatim}

\subsubsubsection{1.3.12.3.1. Qu'e le solicita?}

Solicita la password de root.

\subsubsubsection{1.3.12.3.2. Sucede lo mismo que en 1.3.11.2?¿Por qu'e?}

No, cuando se realiz'o lo mismo con el usuario \textbf{root} no fue necesario ingresar la password. Esto se debe a que el usuario \textbf{nobody} pertenece al grupo \textbf{nogroup}, quienes no tienen permisos para loguearse como \textbf{root} y, de hecho, casi no poseen ningun tipo de privilegios.

\subsubsection{rm}

Suprima el archivo \textbf{/usr/$<$grupo$>$/passwd}.
\begin{verbatim}
    # ls /usr/grupo8
    passwd
    # rm /usr/grupo8/passwd
    # ls /usr/grupo8
    #
\end{verbatim}

\subsubsection{ln}

Enlazar el archivo \textbf{/etc/passwd} a los siguientes archivos \textbf{/tmp/contra1} \textbf{/tmp/contra2}.
Hacer un ls -l para ver cuantos enlaces tiene \textbf{/etc/passwd}.

\begin{verbatim}
    # ls -l /etc/passwd
    -rw-r--r-- 1 root operator 314 Apr 15 2007 /etc/passwd
    # ln /etc/passwd /tmp/contra1
    # ln /etc/passwd /tmp/contra2
    # ls -l /etc/passwd
    -rw-r--r-- 3 root operator 314 Apr 15 2007 /etc/passwd
    #
\end{verbatim}

En el listado del archivo, la segunda columna (luego de los permisos) indica la cantidad de links que tiene ese archivo.

\subsubsection{mkfs}

Genere un Filesystem MINIX en un diskette

\begin{verbatim}
    # mkfs /dev/fd0
\end{verbatim}

\subsubsection{mount}

\subsubsubsection{M'ontelo en el directorio \textbf{/mnt}.}

\begin{verbatim}
    # mount /dev/fd0 /mnt
    /dev/fd0 is read-write mounted on /mnt
    #
\end{verbatim}

\subsubsubsection{Presente los filesystems que tiene montados.}

\begin{verbatim}
    # mount
    /dev/hd1 is root device
    /dev/hd2 is mounted on /usr
    /dev/fd0 is mounted on /mnt
    #
\end{verbatim}


\subsubsection{df}

\subsubsubsection{Qu'e espacio libre y ocupado tienen todos los filesystems montados?(en KBYTES)}

\begin{verbatim}
# df
Device    Inodes Inodes Inodes  Blocks Blocks Blocks  Mounted   V Pr
           total  used   free    total  used   free      on         
           -----  -----  -----   -----  -----  -----    ------   - --
/dev/hd1    496    212    284     1480    700    780    /        2 rw
/dev/hd2  12528   3309   9219    75096  27443   47653   /usr     2 rw
/dev/fd0    480      1    479     1440     35    1405   /mnt     2 rw
#
\end{verbatim}

En todos los dispositivos, el tama'no de bloque es 1KB, por lo tanto el espacio disponible en KB es el indicado por la columna \textbf{Blocks free} y el espacio ocupado es el indicado por la columna \textbf{Blocks used}.

\subsubsection{ps}

\subsubsubsection{1.3.18.1. ¿Cuántos procesos de usuario tiene ejecutando?}

\begin{verbatim}
    # ps -a
    PID TTY  TIME CMD
     41  co  0:00 -sh
     42  c1  0:00 getty
     47  c0  0:00 ash
     48  c0  0:00 ps -a
\end{verbatim}

Los procesos de usuario que se est'an ejecutando son 4 (incluyendo al \textbf{ps}).

\subsubsubsection{1.3.18.2. Indique cu'antos son del sistema}

\begin{verbatim}
    # ps -ax
    PID TTY  TIME CMD
      0   ?  0:00 TTY
      0   ?  0:00 SCSI
      0   ?  0:00 WINCH
      0   ?  0:00 SYN_AL
      0   ?  8:35 IDLE
      0   ?  0:00 PRINTER
      0   ?  0:00 FLOPPY
      0   ?  0:00 MEMORY
      0   ?  0:00 CLOCK
      0   ?  0:01 SYS
      0   ?  0:06 HARDWAR
      0   ?  0:00 MM
      0   ?  0:04 FS
      1   ?  0:00 INIT
     40  co  0:00 -sh
     27   ?  0:00 update
     41  c1  0:00 getty
     47  co  0:00 ash
     57  co  0:00 ps -ax
    #
\end{verbatim}

Aqu'i se listan todos los procesos incluyendo tambi'en a los de usuario. En total hay 18 procesos ejecut'andose, 4 son de usuario y 15 del sistema.

\subsubsection{umount}

\subsubsubsection{1.3.19.1. Desmonte el Filesystem del directorio /mnt}

\begin{verbatim}
    # umount /dev/fd0
    /dev/fd0 unmounted from /mnt
    #
\end{verbatim}

\subsubsubsection{1.3.19.2. Monte el Filesystem del diskette como read-only en el directorio /mnt}

\begin{verbatim}
    # mount /dev/fd0 /mnt -r
    /dev/fd0 is read-only mounted on /mnt
    #
\end{verbatim}

\subsubsubsection{1.3.19.3. Desmonte el Filesystem del directorio /mnt}

\begin{verbatim}
    # umount /dev/fd0
    /dev/fd0 unmounted from /mnt
    #
\end{verbatim}

\subsubsection{fsck}

\subsubsubsection{Chequee la consistencia de Filesystem del diskette}

\begin{verbatim}
    # fsck /dev/fd0

    Checking zone map
    Checking inode map
    Checking inode list
    
    blocksize =  1024        zonesize  =  1024
    
         0    Regular files
         1    Directory
         0    Block special files
         0    Character special files
       479    Free inodes
         0    Named pipes
         0    Symbolic links
      1405    Free zones
    #
\end{verbatim}

\subsubsection{dosdir}

\subsubsubsection{Tome un diskette formateado en DOS con archivos y ejecute $dosdir a$}

\begin{verbatim}
    #dosdir a
    dosdir: cannot open /dev/dosA: no such file or directory
    #
\end{verbatim}

\subsubsubsection{Ejecute los comandos necesarios para que funcione correctamente el comando anterior}
El diskette con formato DOS est'a en \textbf{/dev/fd1}

\begin{verbatim}
    #dosdir fd1
    HOLADOS.TXT
    ABMUSR
    GETNEXTG
    MACHAQUE
    #
\end{verbatim}

\subsubsection{dosread}

\subsubsubsection{Copie un archivo de texto desde un diskette DOS al directorio \textbf{/tmp}}

\begin{verbatim}
    #dosread fd1 HOLADOS.TXT
    hola mundo!

    #dosread -a fd1 HOLADOS.TXT > /tmp/holaminix.txt
    #cat /tmp/holaminix.txt
    hola mundo!

    #
\end{verbatim}

\subsubsection{doswrite}

\subsubsubsection{Copie el archivo \textbf{/etc/passwd} al diskette DOS}

\begin{verbatim}
    #doswrite -a fd1 passwd < /etc/passwd
    #dosdir fd1
    HOLADOS.TXT
    ABMUSR
    GETNEXTG
    MACHAQUE
    PASSWD
    #
\end{verbatim}

\subsection{Ejercicio 4: Uso de STDIN, STDOUT, STDERR y PIPES}
\subsubsection{STDOUT}
\subsubsubsection{1.4.1.1. Conserve el archivo /usr/$<$grupo$>$/fuentes.txt la salida del comando ls que muestra todos los archivos del directorio /usr/src y de los subdirectorios bajo /usr/src}

\begin{verbatim}
    # cd /usr/grupo8
    # ls -al /usr/src > /usr/grupo8/fuentes.txt
    #
\end{verbatim}

\subsubsubsection{1.4.1.2. Presente cuantas lineas, palabras y caracteres tiene /usr/$<$grupo$>$/fuentes.txt}

\begin{verbatim}
    # wc /usr/grupo8/fuentes.txt
         25    218   1455 /usr/grupo8/fuentes.txt
    #
\end{verbatim}

El archivo \textbf{/usr/grupo8/fuentes.txt} tiene 25 líneas, 218 palabras y 1455 caracteres.

\subsubsection{STDOUT}
\subsubsubsection{1.4.2.1. Agregue el contenido, ordenado alfab'eticamente, del archivo /etc/passwd al final del archivo /usr/$<$grupo$>$/fuentes.txt}

\begin{verbatim}
    # sort /etc/passwd >> /usr/grupo8/fuentes.txt
\end{verbatim}

\subsubsubsection{1.4.2.2. Presente cu'antas lineas, palabras y caracteres tiene usr/$<$grupo$>$/fuentes.txt}

\begin{verbatim}
    # wc /usr/grupo8/fuentes.txt
         34    234   1769 /usr/grupo8/fuentes.txt
    #
\end{verbatim}

El archivo \textbf{/usr/grupo8/fuentes.txt} tiene 34 líneas, 234 palabras y 1769 caracteres.

\subsubsection{STDIN}

\subsubsubsection{1.4.3.1. Genere un archivo llamado /usr/$<$grupo$>$/hora.txt usando el comando echo con el siguiente contenido: 2355}

\begin{verbatim}
    # echo 2355 > /usr/grupo8/hora.txt
\end{verbatim}

\subsubsubsection{1.4.3.2. Cambie la hora del sistema usando el archivo /usr/$<$grupo$>$/hora.txt generado en 1.4.3.1}

\begin{verbatim}
    # date -q < /usr/grupo8/hora.txt
\end{verbatim}

\subsubsubsection{1.4.3.3. Presente la fecha del sistema}

\begin{verbatim}
    # date
    Mon Aug 20 23:55:07 MET DST 2007
    #
\end{verbatim}

\subsubsection{STDERR}

\subsubsubsection{Guarde el resultado de ejecutar el comando dosdir k en el archivo /usr/$<$grupo$>$/error.txt. Muestre el contenido de /usr/<grupo>/error.txt.}

\begin{verbatim}
    # dosdir k > /usr/grupo8/error.txt 2>&1
    # cat /usr/grupo8/error.txt
    dosdir: cannot open /dev/dosK: No such file or directory
    #
\end{verbatim}

\subsubsection{PIPES}
Posici'onese en el directorio \textbf{/}(directorio ra'iz), una vez que haya hecho eso:
\subsubsubsection{1.4.5.1. Liste en forma amplia los archivos del directorio /usr/bin que comiencen con la letra s. Del resultado obtenido, seleccione las l'ineas que contienen el texto sync e informela cantidad de caracteres, palabras y l'ineas.}
Nota 1: Est'a prohibido, en este 'item, usar archivos temporales de trabajo. 

Nota 2: Si le da error, es por falta de memoria, cierre el proceso de la otra sesi'on, haga un kill sobre los procesos update y getty.

\begin{verbatim}
    # pwd
    /
    # ls -lc /usr/bin/s* | grep sync | wc
          2     18    140
    #
\end{verbatim}

2 líneas, 18 palabras y 140 caracteres.

\subsection{Ejercicio 5}
El comando que realiza las tareas es \textbf{abmusr} y su uso es

Para agregar al usuario arturo: \verb0abmusr -a arturo grupoarturo /usr/arturo0

Para borrar al usuario arturo: \verb0abmusr -b arturo0

\subsection{Ejercicio 6: Ejecuci'on de procesos en Background}
Crear el siguiente programa 
\begin{verbatim}
/usr/src/loop.c
#include <stdio.h>
int main()
{
  int i, c;
  while(1)
  {
    c = 48 + i;
    printf("%d",c);
    i++;
    i = i % idgrupo;
  }
}
\end{verbatim}

\subsubsubsection{Compilarlo. El programa compilado debe llamarse loop. Indicando a la macro idgrupo el valor de su grupo.}

Creamos el programa y lo guardamos en el directorio \textbf{/usr/src}. Para compilar el programa realizamos los siguientes pasos:

\begin{verbatim}
    # pwd
    /usr/src
    # cc loop.c -oloop
    #
\end{verbatim}

\subsubsubsection{(a) Correrlo en foreground ¿Qu'e sucede? Mate el proceso con el comando kill.}

Ejecutamos el programa en foreground y notamos que la pantalla se llena de n'umeros, es decir, se produce una impresi'on indefinida de n'umeros en pantalla. La consola queda inutilizable ya que el programa est'a en un loop infinito.

\begin{verbatim}
# ./loop
2535455484950515253545548495051525354554849505152535455484950515253545
2535455484950515253545548495051525354554849505152535455484950515253545
2535455484950515253545548495051525354554849505152535455484950515253545
2535455484950515253545548495051525354554849505152535455484950515253545
2535455484950515253545548495051525354554849505152535455484950515253545
2535455484950515253545548495051525354554849505152535455484950515253545
\end{verbatim}

Como necesitamos saber el PID del proceso para usar kill, creamos una nueva consola mediante Alt+F2 y en ella ejecutamos los siguientes comandos:

\begin{verbatim}
    Minix Release 2.0 Version 0
    noname login: root
    Password:
    # ps 
    PID TTY  TIME CMD
     40  co  0:00 -sh
     41  c1  0:00 -sh
     47  co  0:00 ash
     49  co  0:46 ./loop
     53  c1  0:00 ash
     54  c1  0:00 ps
    # kill 49
    #
\end{verbatim}

Esto causa que en la primer consola el programa finalice con la leyenda \textbf{Terminated}.

\begin{verbatim}
2484950515248495051524849505152484950515248495051524849505152484950515
2484950515248495051524849505152484950515248495051524849505152484950515
2484950515248495051524849505152484950515248495051524849505152484950515
2484950515248495051524849505152484950515248495051524849505152484950515
24849505152484950515248Terminated
\end{verbatim}

\subsubsubsection{(b) Ahora ejec'utelo en background}
\indent \textbf{/usr/src/loop $>$ /dev/null \&}
\subsubsubsection{¿Qu'e se muestra en la pantalla?}

Al ejecutarlo en background, el shell devuelve el ID del proceso. Al estar siendo redirigida la salida a null no imprime nada en pantalla.

\begin{verbatim}
# pwd
/usr/src
# ./loop > /dev/null &
#
\end{verbatim}

Cabe aclarar que si el usuario logueado cambi'o su shell, por ejemplo cambi'o a \textbf{ash}, no visualizar'a el ID del proceso y deber'a realizar un \textbf{ps -a} para obtenerlo.

\subsubsubsection{¿Qu'e sucede si presiona la tecla F1? ¿Qué significan esos datos?}

La tecla F1, muestra una tabla con los procesos del sistema. 'Esta tabla contiene datos del proceso y datos del sistema. Presenta las siguientes columnas:

\begin{itemize}

\item \textbf{pid}: El identificador del proceso. Puede ser el PID asignado por el MM, o puede ser el spot en la tabla de procesos, es decir el p nr, si este es menor a 0.
\item \textbf{pc}: Indica el valor del Program Counter en el momento en que el proceso fue bloqueado.
\item \textbf{sp}: Indica la direcci'on del puntero al tope del stack del proceso.
\item \textbf{flag}: Indica el valor del word de los flags. Si no hay ning'un flag activado, es decir, si este valor es 0, el proceso puede ser ejecutado, en caso contrario se encuentra bloqueado o a'un no fue inicializado.
\item \textbf{user}: Tiempo que el proceso estuvo utilizando el procesador. Est'a medido en "ticks", aproximadamente hay 60 ticks por segundo (59,7 medido, pero bajo Bochs por lo que es inexacto).
\item \textbf{sys}: Tiempo de ejecuci'on de rutinas de sistema relacionadas a la administraci'on de 'este proceso. Tambi'en medido en "ticks"
\item \textbf{text}: Direcci'on f'isica donde comienza el segmento TEXT, o de c'odigo, asignado al proceso.
\item \textbf{data}: Direcci'on f'isica donde comienza el segmento DATA, o de datos, asignado al proceso.
\item \textbf{size}: Tama'no del espacio ocupado en memoria por el proceso en KB.
\item \textbf{recv}: Si el proceso se encuentra bloqueado en espera de el envio o recepci'on de un mensaje, este campo indica quien es el receptor o emisor de dicho mensaje. Caso contrario, est'a en blanco.
\item \textbf{command}: Indica el nombre del proceso.
\end{itemize}

\subsubsubsection{¿Qu'e sucede si presiona la tecla F2? ¿Qu'e significan esos datos?}

Al presionar F2 se obtiene informaci'on sobre el mapa de memoria de los procesos
(estructura mem map en \textbf{/usr/include/minix/type.h}). La tabla presenta
las siguientes columnas:

\begin{itemize}
\item \textbf{PROC}: Indica el slot en la tabla de procesos, es decir el p nr.
\item \textbf{NAME}: Indica el nombre del proceso.
\item \textbf{TEXT}: Para el segmento de c'odigo indica la direcci'on virtual, la direcci'on f'isica y el tama'no, en ese orden.
\item \textbf{DATA}: Para el segmento de datos indica la direcci'on virtual, la direcci'on f'isica y el tama'no, en ese orden.
\item \textbf{STACK}: Para el segmento de stack, o pila, indica la direcci'on virtual, la direcci'on f'isica y el tama'no, en ese orden.
\item \textbf{SIZE}: Tama'no del espacio ocupado en memoria por el proceso.
\end{itemize}


\subsection{Ejercicio 7}
\subsection{Ejercicio 8}
\subsection{Ejercicio 9}
\subsection{Ejercicio 10: Modificaci'on de c'odigos}
\begin{description}
\item[a.] Modique el "scheduler"\ original del MINIX para el nivel de usuarios.
\item[b.] Modifique la administraci'on de memoria original del MINIX
\end{description}
En ambos casos deber'a describir en el informe cu'ales fueron las decisiones tomadas, cu'ales fueron las espectativas y cu'ales fueron los resultados obtenidos e informar el juego de programas utilizados con los cuales se lleg'o a alguna conclusi'on. (test o pruebas mencionados en Forma de entrega).

\subsubsection{Modique el "scheduler"\ original del MINIX para el nivel de usuarios}
\subsubsubsection{Decisiones tomadas}

La administraci'on de procesos de Minix divide a los procesos en tres categor'ias: procesos de usuario, procesos SERVER (como ser MM, o FS) y procesos TASK (kernel). Asimismo, para los procesos de usuario, utiliza una administraci'on $Round-Robin$, y un proceso s'olo podr'a perder el recurso procesador por alguna de las tres siguientes razones:

\begin{itemize}
\item El proceso finaliza.
\item Se bloquee por una operaci'on de E/S o sincronizaci'on.
\item El uso exceda un cierto $Quantum$.
\end{itemize}

Decidimos modificar la administraci'on de los procesos de usuario para que cambie de $Round-Robin$ a $FIFO$,

\subsubsubsection{Expectativas}

Como estamos permitiendo un uso m'as prolongado y continuo del recurso procesador, es de esperar que los procesos de alto uso de CPU se vean beneficiados, quiz'as en detrimento de procesos que tengan, en cambio, mayor uso de E/S, ya que 'estos se bloquear'an r'apidamente y estar'an un largo tiempo en espera del recurso.

\subsubsubsection{Resultados}

Nuestra propuesta es modificar el archivo \textbf{/usr/src/kernel/clock.c}. De la siguiente manera: si esta definido UBA\_FCEN, entonces en la funci'on $do\_clocktick$ no se ejecutar'a el c'odigo que realiza la selecci'on de un proceso de usuario nuevo, en el caso en que no haya ni procesos SERVER ni TASK para elegir y adem'as que el proceso anterior haya excedido su $Quantum$.

El c'odigo que no se ejecuta si UBA\_FCEN est'a definido est'a en el Ap'endice A.

Se generaron dos procesos de prueba \textbf{highCPU.c} y \textbf{lowCPU.c}. El primero consiste en la repetici'on de un ciclo que contiene a su vez otro ciclo, en total clica aproximadamente 5000050000 veces. El segundo consiste en la repetici'on de un ciclo 10000 veces. Ambos al terminar muestran por pantalla la etiqueta: "Final de highCPU"\ y "Final de lowCPU"\ respectivamente.

A continuación se muestran los resultados obtenidos con la administraci'on $Round-Robin$:

\begin{verbatim}
    # cd /usr/grupo8/ej10
    # ls
    highCPU highCPU.c lowCPU lowCPU.c
    #./highCPU & ./lowCPU 
    Final de lowCPU
    # Final de highCPU
    #
    #./lowCPU & ./highCPU
    Final de lowCPU
    # Final de highCPU
\end{verbatim}

Si cambiamos a la administraci'on a $FIFO$ obtenemos los siguientes valores:

\begin{verbatim}
    # cd /usr/grupo8/ej10
    # ls
    highCPU highCPU.c lowCPU lowCPU.c
    #./highCPU & ./lowCPU 
    Final de lowCPU
    # Final de highCPU
    #
    #./lowCPU & ./highCPU
    Final de highCPU
    # Final de lowCPU
\end{verbatim}

Con la administraci'on $Round-Robin$ lowCPU siempre termina primero. Debido a que hace poco uso del procesador (menos que highCPU) y adem'as tiene su "\ cuota"\ de procesador correspondiente debido al tipo de administraci'on. Esto hace que termine de ejecutar antes que highCPU.

Con la administraci'on $FIFO$ termina primero el que obtiene el recurso procesador primero. Ninguno de los procesos se bloquea, dando lugar a ejecutar al otro, ya que no realizan E/S.

\subsubsection{Modifique la administraci'on de memoria original del MINIX}

\subsubsubsection{Decisiones tomadas}
MINIX utiliza administraci'on de memoria particionada variable, con $primer\ zona$ (first fit) como algoritmo de selecci'on. Se cambi'o el procedimiento de alocaci'on de memoria para que utilice el algoritmo de selecci'on $mayor\ zona$.

El c'odigo modificado se encuentra en el Ap'endice A.

\subsubsubsection{Expectativas}
'Estas administraciones fueron vistas durante el curso. Tanto la administraci'on $mayor\ zona$ como la administraci'on "golosa" de $first\ fit$ tienen casos en la que resultan buenas y casos en las que no. Con lo cual no se espera alg'un comportamiento en particular, salvo porque se deber'ia de estar tomando siempre el segmento de mayor tama'no.

\subsubsubsection{Resultados}
Para realizar las modificaciones, cambiamos la secci'on de alocaci'on de memoria que ocurre en la funci'on $alloc\_mem$ del archivo \textbf{/usr/src/mm/alloc.c}. En ella se hace un while recorriendo los segmentos libres en la memoria del sistema en busca del de mayor tama'no. Cuando se encuentra (en el caso en que cubra el requerimiento) nos quedamos con ese lugar, caso contrario se devuelve un mensaje de error (Ver Ap'endice).

Para poder ver los resultados agregamos dentro de la funci'on c'odigo que nos muestra el tama'no de los segmentos libres antes y despu'es de la alocaci'on. Para que dicho c'odigo se ejecute debe estar definida la variable DEBUGG. Dicha variable se encuentra en \textbf{/usr/include/minix/config.h}.

Usamos el programa de test 4000Clicks.c que puede encontrarse en la carpeta \textbf{/usr/grupo8/ej10}:
\begin{verbatim}
    static char datos [4000*256]; /* reserva 1000k */
    int main ( void)
    {
    return 0 ;
    }
\end{verbatim}

Este programa lo 'unico que hace es reservar 4000 clicks (de 256 Bytes) de memoria que es equivalente a 1000 KB.
Lo ejecutamos y observamos lo siguiente:

\begin{verbatim}
    # ls
    Se quiere reservar 306 espacios de memoria
    1936 514 67 5860
    Los segmentos quedaron de la siguiente manera
    1936 514 67 5554
    Se quiere reservar 440 espacios de memoria
    1936 514 67 5860
    Los segmentos quedaron de la siguiente manera
    1936 514 67 5420
    4000Clicks 4000Clicks.c
    # ./4000Clicks
    Se quiere reservar 306 espacios de memoria
    1936 514 67 5860
    Los segmentos quedaron de la siguiente manera
    1936 514 67 5554
    Se quiere reservar 4514 espacios de memoria
    1936 514 67 5860
    Los segmentos quedaron de la siguiente manera
    1936 514 67 1346
    #
\end{verbatim}

Notar que el cambio fue el deseado, ya que al pedir memoria siempre se ocupa el segmento de mayor tama'no. Usando la administraci'on anterior se ubiese ocupado el primer bloque.

Aclaraci'on: El click es la unidad b'asica de tama'no de memoria. Si el procesador es Intel est'a definida como 256 Bytes y var'ia para otros procesadores. Estos $define$ se encuentran en $const.h$.
Para poder ver como se va modificando la memoria hay que bootear con la imagen $imagMemChck$ que est'a en el directorio \textbf{/minix}. %Las otras im'agenes tambi'en tienen la modificaci'on en la administraci'on de memoria pero el "debug"\ est'a \"apagado".


\subsection{Ejercicio 11}
Se realizaron los siguientes cambios

\verb0/usr/include/minix/callnr.h0

Se incrementó en 1 el define NCALLS
Se agregó \verb0#define LLAMSISTEMA0 con el nro correspondiente 

\verb0/usr/src/mm/table.c0

Nota: no se usó el nombre pedido x la cátedra (newcall), ya que este fue usado para otras pruebas. Se realizó una version del getpid desde MM y desde FS, sendas llamadas a sistema con nombres newcall y othercall respectivamente. 

El el mismo directorio el newcall.c y el othercall.c son source para probar dichas funciones
\begin{verbatim}
./newcall
./othercall
\end{verbatim}

Tienen la misma funcionalidad que \verb0./llam 10


\subsubsection{Pruebas}

En imagen minix para ejercicio 11

Fuente: \verb0/usr/ej11/llam.c0

Ejecutable: \verb0/usr/ej11/llam0

Modo de prueba

\begin{verbatim}
./llam [opcion]
\end{verbatim}

Opcion es del 1 al 5

\begin{enumerate}
\item Entrega el pid del programa
\item Entrega el pid del padre, que, al estar implementado en MM, es el pid del mm o sea 0
\item Entrega el puntero al segmento text, en hexadecimal
\item Entrega el puntero al segmento data, en hexadecimal
\item Entrega el puntero al segmento stack, en hexadecimal
\end{enumerate}

Para las opciones 3, 4 y 5, para verificar la correctitud de la misma se agregó un ciclo while para evitar que el programa termine. Al ejecutar el programa con algunas de estas opciones, al presionar F2 veremos la informacion de los segmentos correspondientes. Para matar al proceso, abrimos otra consola, ejecutamos ps para ver el nro del mismo y con el comando \verb0kill [nro proc]0 lo eliminamos.

\subsection{Ejercicio 12}

\clearpage
\section{Ap'endice A}
A continuaci'on se muestra el c'odigo de la funci'on $do\_clocktick$ que no se ejecutar'a si est'a definido UBA\_FCEN. Dicha funci'on se encuentra en el archivo \textbf{/usr/src/kernel/clock.c}.

\begin{verbatim}
[...]
#ifndef UBA_FCEN
  /* If a user process has been running too long, pick another one. */

  if (--sched_ticks == 0) {
        if (bill_ptr == prev_ptr) lock_sched(); /* process has run too long */
        sched_ticks = SCHED_RATE;               /* reset quantum */
        prev_ptr = bill_ptr;                    /* new previous process */
  }
#endif
\end{verbatim}



Aqu'i se ver'a como fue modificada la funci'on $alloc\_mem$, la cual se encuentra en el archivo \textbf{/usr/src/mm/alloc.c}.

\begin{verbatim}
[...]
/*======================================================================*
* alloc_mem *
*======================================================================*/
#ifdef UBA_FCEN

PUBLIC phys_clicks alloc_mem(clicks)
phys_clicks clicks; 
{
  register struct hole *max, *anterior;
  phys_clicks old_base;
  register struct hole *actual, *debugg;
  actual = hole_head;
  max = hole_head;

#ifdef DEBUGG

  /*DEBUGER: para ver como es el estado inicial de la memoria*/
  debugg = hole_head;
  printf("Se quiere reservar %d espacios de memoria \n",clicks);
  while (debugg != NIL_HOLE)
  {
    printf("%d ",debugg->h_len);
    debugg = debugg->h_next;
  }
  printf("\n");
  /***********************************************************/

#endif

  while (actual->h_next != NIL_HOLE)
  {
    if (actual->h_next->h_len > max->h_len)
    {
      max = actual->h_next;
      anterior = actual;
    }
    actual = actual->h_next;
  }

  if (max->h_len < clicks)
  }
    return(NO_MEM);
  }
  else
  {
    old_base = max->h_base;
    max->h_base += clicks;
    max->h_len -= clicks;
  }

  if (max->h_len == 0)
  {
    del_slot(anterior, max);
  }

#ifdef DEBUGG

  /*DEBUG: para ver como queda la memoria una vez hecha la alicacion*/
  debugg = hole_head;
  printf("Los segmentos de memoria quedaron de la siguiente manera \n");
  while (debugg != NIL_HOLE)
  {
    printf("%d ",debugg->h_len);
    debugg = debugg->h_next;
  }
  printf("\n");
  /******************************************************************/

#endif

  return(old_base);
}

#else

PUBLIC phys_clicks alloc_mem(clicks)
phys_clicks clicks;             /* amount of memory requested */
{
/* Allocate a block of memory from the free list using first fit. The block
 * consist of a sequence of contiguous bytes, whose length in clicks is 
 * given by 'clics'.  A pointer to the block is returned.  The block is 
 * always on a click boundary. This procedure is called when memory is
 * needed for FORK or EXEC.
 */
  
  register struct hole *hp, *prev_ptr;
  phys_clicks old_base;

  hp = hole_head;
  while (hp != NIL_HOLE) {
        if (hp->h_len >= clicks) {
            /* We found a hole that is big enough.  Use it. */
            old_base = hp->h_base;  /* remember where it started */
            hp->h_base += clicks;   /* bite a piece off */
            hp->h_len -= clicks;    /* ditto */

            /* If hole is only partly used, reduce size and return. */
            if (hp->h_len != 0) return (old _base);

            /* The entire hole has been used up.  Manipulate free list. */
            del_slot(prev_ptr, hp);
            return(old_base);
        }
        
        prev_ptr = hp;
        hp = hp->h_next;
  }
  return(NO_MEM);
}

#endif
[...]
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Referencias
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Referencias}
\begin{itemize}
\item Sistemas Operativos - Dise'no e Implementaci'on (Andrew Tanenbaum - Prentice Hall 1998)
\item http://www.minix3.org/
\item http://es.wikipedia.org/wiki/Chmod
\item 
\end{itemize}
\end{document}
%%%
% EOF
%%%%%%%%%%%%%%%%%%%%%
